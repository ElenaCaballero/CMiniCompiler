package cminicompiler;

import java_cup.runtime.*;
import java.io.Reader;
import classes.*;

parser code {:

	public CMiniProgram root = null;

	public void report_error(String message, Object info) {
		StringBuilder m = new StringBuilder("Syntax Error");
		if (info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
			if (s.left >= 0) {
				m.append(" at line "+(s.left+1));
				if (s.right >= 0)
					m.append(", column "+(s.right+1));
			}
		}
		m.append(" : "+message);
		System.err.println(m);
	}

	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		//System.exit(1);
	}

	public void syntax_error(Symbol cur_token) {
		report_error("on Token "+ cur_token.value, cur_token);
	}

:};

terminal INT, CHAR, BOOLEAN, CONSTCHAR, VOID, PRINTF,
	SCANF, ARTHMEXPSUM, ARTHMEXPMULT, BOOLEXP, SEMICOLON,
	COMMA, LEFTPRNTH, RIGHTPRNTH, LEFTCBRAC, RIGHTCBRAC, 
	EQUALS, OR, AND, FOR, WHILE, IF, ELSE, RETURN, BREAK,
	NULL, BOOLTOF, ID, DECIMALINT, SINGLECHAR, INTEGER, 
	MAIN, AMPERSAND, ASTERISK;
terminal String CONSTSTR;

non terminal CMiniProgram cMiniProgram;
non terminal MainClause mainClause;
non terminal FunctionDeclaration functionDeclaration;
non terminal FunctionList functionList;
non terminal Function function;
non terminal Argument argument;
non terminal ArgumentList argumentList;
non terminal Expression expression;
non terminal Expressions expressions;
non terminal Type type;
non terminal ReturnStatement returnStatement;
non terminal VariableDeclaration variableDeclaration;
non terminal Statements statements;
non terminal Scanners scanners;
non terminal Printers printers;
non terminal Variables variables;
non terminal Value value;
non terminal IfStatement ifStatement;
non terminal ElseStatement elseStatement;
non terminal Condition condition;
non terminal WhileStatement whileStatement;
non terminal ForStatement forStatement;
non terminal Inits inits;
non terminal ForArthmExp forArthmExp;
non terminal AndOR andOr;
non terminal ArithmeticExp arithmeticExp; 
non terminal ArithmeticExp artExp; 
non terminal Term term;
non terminal Factor factor;
non terminal Assignment assignment;
non terminal Assignment assignmentProc;
non terminal String opsum;
non terminal String opmult;
non terminal String operators;

precedence left OR;
precedence nonassoc BOOLEXP;
precedence left ARTHMEXPSUM;
precedence left ARTHMEXPMULT;
precedence left LEFTPRNTH, RIGHTPRNTH, LEFTCBRAC, RIGHTCBRAC;
precedence right ELSE;
precedence left ID;

start with cMiniProgram;

cMiniProgram ::= mainClause:mc {:
					CMiniProgram r = new CMiniProgram(mc);
					RESULT = r;
					parser.root = RESULT;
				:}
				| functionDeclaration:fd mainClause:mc functionList:fl {:
					CMiniProgram r = new CMiniProgram(fd, mc, fl);
					RESULT = r;
					parser.root = RESULT;
				:}
				;

mainClause ::= type:t MAIN:m LEFTPRNTH argumentList:a RIGHTPRNTH LEFTCBRAC expressions:e RIGHTCBRAC {:
					MainClause r = new MainClause(t, (String)m, a, e);
					RESULT = r;
				:}
				;

functionDeclaration ::= type:t ID:id LEFTPRNTH argumentList:a RIGHTPRNTH SEMICOLON {:
					FunctionDeclaration r = new FunctionDeclaration(t, (String)id, a);
					RESULT = r;
				:}
				;

functionList ::= function:f functionList:fl {:
					FunctionList r = new FunctionList(fl, f);
					RESULT = r;
				:}
				| function:f {:
					FunctionList r = new FunctionList(f);
					RESULT = r; 
				:}
				;

function ::= type:t ID:id LEFTPRNTH argumentList:a RIGHTPRNTH LEFTCBRAC expressions:e RIGHTCBRAC {:
					Function r = new Function(t, (String)id, a, e);
					RESULT = r;
				:}
				;

argumentList ::= argument:a COMMA argumentList:al {:
					ArgumentList r = new ArgumentList(al, a);
					RESULT = r;
				:}
				| argument:a {:
					ArgumentList r = new ArgumentList(a);
					RESULT = r;
				:}
				|  {:
					RESULT = null;
				:}
				;

argument ::= type:t ID:id  {:
					Argument r = new Argument(t, (String)id);
					RESULT = r;
				:}
				;

expressions ::= expression:e expressions:es {:
					Expressions r = new Expressions(es, e);
					RESULT = r;
				:}
				| expression:e {:
					Expressions r = new Expressions(e);
					RESULT = r;
				:}
				;

expression ::= variableDeclaration:vd {:
					Expression r = new Expression(vd);
					RESULT = r;
				:}
				| statements:s {:
					Expression r = new Expression(s);
					RESULT = r;
				:}
				| scanners:s {:
					Expression r = new Expression(s);
					RESULT = r;
				:}
				| printers:p {:
					Expression r = new Expression(p);
					RESULT = r;
				:}
				| artExp:a  {:
					Expression r = new Expression(a);
					RESULT = r;
				:}
				| returnStatement:rs {:
					Expression r = new Expression(rs);
					RESULT = r;
				:}
				| assignmentProc:a {:
					Expression r = new Expression(a);
					RESULT = r;
				:}
				| BREAK:b {:
					Expression r = new Expression((String)b);
					RESULT = r;
				:}
				;

returnStatement ::= RETURN:ret value:val SEMICOLON{:
						ReturnStatement r = new ReturnStatement((String)ret, val);
					:}
					;

variableDeclaration ::= type:t variables:v SEMICOLON {:
							VariableDeclaration r = new VariableDeclaration(t, v);
							RESULT = r;
						:}
						;

variables ::= ID:id {:
					Variables r = new Variables((String)id);
					RESULT = r;
				:}
			  	| ID:id COMMA variables:v {:
		  			Variables r = new Variables((String)id, v);
		  			RESULT = r;
		  		:}
			  	| ID:id EQUALS value:val {:
		  			Variables r = new Variables((String)id, val);
		  			RESULT = r;
		  		:}
			  	| ID:id EQUALS value:val COMMA variables:v {:
			  		Variables r = new Variables((String)id, val, v);
			  		RESULT = r;
		  		:}
			  	;

statements ::= ifStatement:ifs 	{: 
					Statements r = new Statements(ifs);
					RESULT = r; 
				:}	
				|whileStatement:wS {:
					Statements r = new Statements(wS);
					RESULT = r; 	
				:}
				|forStatement:fS {:
					Statements r = new Statements(fS);
					RESULT = r; 	
				:}
				;

ifStatement ::= IF:i LEFTPRNTH condition:c RIGHTPRNTH LEFTCBRAC expressions:e RIGHTCBRAC{:
					IfStatement r = new IfStatement((String)i, c, e);
					RESULT = r;
				:}
				|ifStatement:i elseStatement:eS {:
					IfStatement r = new IfStatement(i, eS);
					RESULT = r;
				:} 
				;

elseStatement ::= ELSE:eS LEFTCBRAC expressions:e RIGHTCBRAC {: 
					ElseStatement r = new ElseStatement((String)eS, e);
					RESULT = r;
				:}
				| ELSE:e ifStatement:ifS {:
					ElseStatement r = new ElseStatement((String)e, ifS);
					RESULT = r;
				:}
				;

condition ::= value:v1 operators:b value:v2 {:
				Condition r = new Condition(v1,(String)b,v2);
				RESULT = r;
			:}
			| value:v1 operators:b value:v2 andOr:aO {:
				Condition r = new Condition(v1,(String)b,v2,aO);
				RESULT = r;
			:}
			;

operators ::= BOOLEXP:b {:
				if (b == "<") {
					RESULT = "<";
				}else if (b == ">") {
					RESULT = ">";
				}else if (b == "<=") {
					RESULT = "<=";
				}else if (b == ">=") {
					RESULT = ">=";
				}else if (b == "!=") {
					RESULT = "!=";
				}else if (b == "==") {
					RESULT = "==";
				}else{
					
				}
			:}
			;

andOr ::= AND:a condition:c {:
			RESULT = new AndOR((String)a,c);
		:}
		| OR:o condition:c {:
			RESULT = new AndOR((String)o,c);
		:}
		;

whileStatement ::= WHILE:w LEFTPRNTH condition:c RIGHTPRNTH LEFTCBRAC expressions:e RIGHTCBRAC {:
					WhileStatement r = new WhileStatement((String)w, c, e);
					RESULT = r;
				:}
				;

forStatement ::= FOR:f LEFTPRNTH inits:i SEMICOLON condition:c SEMICOLON forArthmExp:aE RIGHTPRNTH LEFTCBRAC expressions:e RIGHTCBRAC{:
					ForStatement r = new ForStatement((String)f, i, c, aE, e);
					RESULT = r;
				:}
				;

inits ::= INT:i ID:id EQUALS value:v {:
			Inits r = new Inits((String)i, (String)id,v);
			RESULT = r;
		:}
		;

forArthmExp ::= ID:id ARTHMEXPSUM:aES1 ARTHMEXPSUM:aES2 {:
				ForArthmExp r = new ForArthmExp((String)id, (String)aES1, (String)aES2);
				if(aES1 != aES2){
					
				}
				RESULT = r;
			:}
			| ID:id ARTHMEXPSUM:aES EQUALS:eq INTEGER:num {:
				ForArthmExp r = new ForArthmExp((String)id, (String)aES, (String)eq, (int)num);
			:}
			| ID:id ARTHMEXPMULT:aES EQUALS:eq INTEGER:num {:
				ForArthmExp r = new ForArthmExp((String)id, (String)aES, (String)eq, (int)num);
			:}
			;

scanners ::= SCANF:sf LEFTPRNTH CONSTSTR:sl COMMA variables:v RIGHTPRNTH SEMICOLON {:
				Scanners r= new Scanners((String)sf,sl,v);
				RESULT = r;
			:}
			;

printers ::= PRINTF:pf LEFTPRNTH CONSTSTR:sl RIGHTPRNTH SEMICOLON {:
				Printers r = new Printers((String)pf,sl);
				RESULT = r;
			:}
			|PRINTF:pf LEFTPRNTH CONSTSTR:sl COMMA variables:v RIGHTPRNTH SEMICOLON{:
				Printers r= new Printers((String)pf,sl,v);
				RESULT = r;
			:}
			| error SEMICOLON {:
				System.err.println("Error printing: Possible missing token at the end of a declaration line.");
			:}
			;

value ::= ID:id {:
				RESULT = new Value((String)id, "id");
			:}
			|INTEGER:num {:
				RESULT = new Value((String)num, "int");
			:}
			|CONSTCHAR:character {:
				RESULT = new Value((String)character, "char");
			:}
			|BOOLTOF:tF {:
				RESULT = new Value((String)tF, "bool");
			:}
			|NULL:n {:
				RESULT = new Value((String)n, "null");
			:}
			;

type ::= INT:i {:
			Type r = new Type((String)i);
			RESULT = r;
		:}
		| CHAR:c {:
			Type r = new Type((String)c);
			RESULT = r;
		:}
		| INT:i ASTERISK:a {:
			Type r = new Type((String)i, (String)a);
			RESULT = r;
		:}
		| CHAR:c ASTERISK:a {:
			Type r = new Type((String)c, (String)a);
			RESULT = r;
		:}
		| BOOLEAN:b {:
			Type r = new Type((String)b);
			RESULT = r;
		:}
		| VOID:v {:
			Type r = new Type((String)v);
			RESULT = r;
		:}
		;

artExp ::= arithmeticExp:ae SEMICOLON {:
			ArithmeticExp r = new ArithmeticExp(ae);
			RESULT = r;
		:}
		;

arithmeticExp ::= arithmeticExp:e opsum:opsum term:t {:
						if (opsum == "+") {
							ArithmeticExp r = new ArithmeticExp(e, "+", t);
							RESULT = r;
						}else if (opsum == "-") {
							ArithmeticExp r = new ArithmeticExp(e, "-", t);
							RESULT = r;
						}
					:}
					|term:t {:
						ArithmeticExp r = new ArithmeticExp(t);
						RESULT = r;
					:}
					;

term ::= term:t opmult:opmult factor:f {:
				if (opmult == "*") {
					Term r = new Term(t, "*", f);
					RESULT = r;
				}else if (opmult == "/") {
					Term r = new Term(t, "/", f);
					RESULT = r;
				}
			:}
			| term:t ASTERISK:ast factor:f {:
				Term r = new Term(t, "*", f);
					RESULT = r;
			:}
			| factor:f {:
				Term r = new Term(f);
				RESULT = r;
			:}
			;

factor ::= LEFTPRNTH arithmeticExp:e RIGHTPRNTH {:
				Factor r = new Factor(e);
				RESULT = r;
			:}
			|value:val {:
				Factor r = new Factor(val);
				RESULT = r;
			:}
			;

opsum ::= ARTHMEXPSUM:op {:
				if (op == "+") {
					RESULT = "+";
				}else if (op == "-") {
					RESULT = "-";
				}
			:}
			;

opmult ::= ARTHMEXPMULT:op {:
				if (op == "*") {
					RESULT = "*";
				}else if (op == "/") {
					RESULT = "/";
				}
			:}
			;

assignmentProc ::= assignment:a SEMICOLON {:
					Assignment r = new Assignment(a);
					RESULT = r;
				:}
				;

assignment ::= ID:id EQUALS arithmeticExp:aE {:
					Assignment r = new Assignment((String)id, aE);
					RESULT = r;
				:}
				;




