package cminicompiler;

import java_cup.runtime.*;
import java.io.Reader;
import classes.*;

parser code {:

	public CMiniProgram root = null;

	public void report_error(String message, Object info) {
		StringBuilder m = new StringBuilder("Sintax Error");
		if (info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
			if (s.left >= 0) {
				m.append(" at line "+(s.left+1));
				if (s.right >= 0)
					m.append(", column "+(s.right+1));
			}
		}
		m.append(" : "+message);
		System.err.println(m);
	}

	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		System.exit(1);
	}

	public void syntax_error(Symbol cur_token) {
		report_error("on Token "+ cur_token.value, cur_token);
	}

:};

terminal INT, CHAR, BOOLEAN, CONSTCHAR, 
    VOID, PRINTF, SCANF, ARTHMEXPSUM, ARTHMEXPMULT, 
    BOOLEXP, SEMICOLON, COLON, COMMA, DOT, LEFTPRNTH, 
    RIGHTPRNTH, LEFTCBRAC, RIGHTCBRAC, LEFTBRAK, RIGHTBRAK, 
    EQUAL, NUMERAL, OR, AND, FOR, WHILE, DO, IF, ELSE, 
    DEFINE, INCLUDE, RETURN, BREAK, NULL, BOOLTOF, ID,
    DECIMALINT, SINGLECHAR, CHAR_CONST, INT_CONST, MAIN;
terminal String STRING_LITERAL;

non terminal CMiniProgram cMiniProgram;
non terminal MainClause mainClause;
non terminal FunctionDeclaration functionDeclaration;
non terminal FunctionList functionList;
non terminal Function function;
non terminal Argument argument;
non terminal ArgumentList argumentList;
non terminal Expression expression;
non terminal Expressions expressions;
non terminal Type type;
non terminal ReturnStatement returnStatement;
non terminal VariableDeclaration variableDeclaration;
non terminal Statements statements;
non terminal Scanners scanners;
non terminal Printers printers;
non terminal Variables variables;
non terminal Value value;
non terminal IfStatement ifStatement;
non terminal ElseStatement elseStatement;
non terminal Condition condition;
non terminal WhileStatement whileStatement;
non terminal ForStatement forStatement;
non terminal Inits inits;
non terminal ArthmExp arthmExp;
non terminal AndOr andOr;



start with cMiniProgram;

cMiniProgram ::= functionDeclaration:fd mainClause:mc functionList:fl {:
					CMiniProgram r = new CMiniProgram(fd, mc, fl);
					RESULT = r;
					parser.root = RESULT;
				:}
				;

mainClause ::= type:i MAIN:m LEFTPRNTH argumentList:a RIGHTPRNTH LEFTCBRAC expressions:e RIGHTCBRAC {:
					MainClause r = new MainClause(i, (String)m, a, e);
					RESULT = r;
				:}
				;

functionDeclaration ::= type:t ID:id LEFTPRNTH argumentList:a RIGHTPRNTH {:
					FunctionDeclaration r = new FunctionDeclaration(t, (String)id, a);
					RESULT = r;
				:}
				|{:
					RESULT = null;
				:}
				;

functionList ::= function:f functionList:fl {:
					FunctionList r = new FunctionList(fl, f);
					RESULT = r;
				:}
				| function:f {:
					FunctionList r = new FunctionList(f);
					RESULT = r; 
				:}
				|{:
					RESULT = null;
				:}
				;

function ::= type:t ID:id LEFTPRNTH argumentList:a RIGHTPRNTH LEFTCBRAC expressions:e RIGHTCBRAC {:
					Function r = new Function(t, (String)id, a, e);
					RESULT = r;
				:}
				;

argumentList ::= argument:a COMMA argumentList:al {:
					ArgumentList r = new ArgumentList(a, al);
					RESULT = r;
				:}
				| argument:a {:
					ArgumentList r = new ArgumentList(a);
					RESULT = r;
				:}
				|{:
					RESULT = null;
				:}
				;

argument ::= type:t ID:id  {:
					Argument r = new Argument(t, (String)id);
					RESULT = r;
				:}
				;

expressions ::= expressions:es SEMICOLON expression:e SEMICOLON returnStatement:rs SEMICOLON {:
					Expressions r = new Expressions(es, e, rs);
					RESULT = r;
				:}
				| expression:e SEMICOLON returnStatement:rs SEMICOLON {:
					Expressions r = new Expressions(e, rs);
					RESULT = r;
				:}
				| returnStatement:rs SEMICOLON {:
					Expressions r = new Expressions(rs);
					RESULT = r;
				:}
				|{:
					RESULT = null;
				:}
				;

expression ::= variableDeclaration:vd {:
					Expression r = new Expression(vd);
					RESULT = r;
				:}
				| statements:s {:
					Expression r = new Expression(s);
					RESULT = r;
				:}
				| scanners:s {:
					Expression r = new Expression(s);
					RESULT = r;
				:}
				| printers:p {:
					Expression r = new Expression(p);
					RESULT = r;
				:}
				;

returnStatement ::= RETURN:ret ID:id {:
						ReturnStatement r = new ReturnStatement(ret, (String)id);
						RESULT = r;
					:}
					| RETURN:ret NUMERAL:num {:
						ReturnStatement r = new ReturnStatement(ret, num); 
						RESULT = r;
					:}
					| RETURN:ret NULL:n {:
						ReturnStatement r = new ReturnStatement(ret, (String)n); 
						RESULT = r;
					:}
					| {:
						RESULT = null;
					:}
					;

variableDeclaration ::= type:t variables:v SEMICOLON {:
							VariableDeclaration r = new VariableDeclaration(t, v);
							RESULT = r;
						:}
						;

variables ::= ID:id {:
					Variables r = new Variables(id);
					RESULT = r;
				:}
			  	| ID:id COMMA variables:v {:
		  			Variables r = new Variables(id, v);
		  			RESULT = r;
		  		:}
			  	| ID:id EQUAL value:val {:
		  			Variables r = new Variables(id, val);
		  			RESULT = r;
		  		:}
			  	| ID:id EQUAL value:val COMMA variables:v {:
			  		Variables r = new Variables(id, val, v);
			  		RESULT = r;
		  		:}
			  	;

statements ::= ifStatement:ifs 	{: 
					Statements r = new Statements(ifs);
					RESULT = r; 
				:}	
				|whileStatement:wS {:
					Statements r = new Statements(wS);
					RESULT = r; 	
				:}
				|forStatement:fS {:
					Statements r = new Statements(fS);
					RESULT = r; 	
				:}
				;

ifStatement ::= IF:i LEFTPRNTH condition:c RIGHTPRNTH LEFTCBRAC expressions:e RIGHTCBRAC elseStatement:eS {:
					IfStatement r = new IfStatement((String)i,c,e,eS);
					RESULT = r;
				:}
				| IF:i LEFTPRNTH condition:c RIGHTPRNTH LEFTCBRAC expressions:e RIGHTCBRAC{:
					IfStatement r = new IfStatement((String)i,c,e);
					RESULT = r;
				:}
				;

elseStatement ::= ELSE:eS LEFTCBRAC expressions:e RIGHTCBRAC {: 
					ElseStatement r = new ElseStatement(eS,e);
					RESULT = r;
				:}
				| ELSE:e ifStatement:ifS {:
					IfStatement r = new IfStatement(e,ifS);
					RESULT = r;
				:}
				;

condition ::= value:v1 BOOLEXP:b value:v2 {:
				Condition r = new Condition(v1,b,v2);
				RESULT = r;
			:}
			| value:v1 BOOLEXP:b value:v2 andOr:aO {:
				Condition r = new Condition(v1,b,v2,aO);
				RESULT = r;
			:}
			;

andOr ::= AND:a condition:c {:
			RESULT = new AndOR(a,c);
		:}
		| OR:o condition:c {:
			RESULT = new AndOR(o,c);
		:}
		;

scanners ::= SCANF:sf LEFTPRNTH STRING_LITERAL:sl COMMA variables:v RIGHTPRNTH SEMICOLON {:
				Scanners r= new Scanners(sf,sl,v);
				RESULT = r;
			:}
			;

printers ::= PRINTF:pf LEFTPRNTH STRING_LITERAL:sl RIGHTPRNTH SEMICOLON {:
				Printers r = new Printers(pf,sl);
				RESULT = r;
			:}
			|PRINTF:pf LEFTPRNTH STRING_LITERAL:sl COMMA variables:v RIGHTPRNTH SEMICOLON{:
				Printers r= new Printers(pf,sl,v);
				RESULT = r;
			:}
			;

value ::= ID:id {:
				RESULT = new Value(id);
			:}
			|NUMERAL:num {:
				RESULT = new Value(num);
			:}
			|STRING_LITERAL:sl {:
				RESULT = new Value(sl);
			:}
			|BOOLTOF:tF {:
				RESULT = new Value(tF);
			:}
			|NULL:n {:
				RESULT = new Value(n);
			:}
			;

type ::= INT:i {:
			Type r = new Type(i);
			RESULT = r;
		:}
		| CHAR:c {:
			Type r = new Type(c);
			RESULT = r;
		:}
		| BOOLEAN:b {:
			Type r = new Type(b);
			RESULT = r;
		:}
		| CHAR_CONST:cC {:
			Type r = new Type(cC);
			RESULT = r;
		:}
		;

whileStatement ::= WHILE:w LEFTPRNTH condition:c RIGHTPRNTH LEFTCBRAC expressions:e RIGHTCBRAC {:
					WhileStatement r = new WhileStatement(w,c,e);
					RESULT = r;
				:}
				;

forStatement ::= FOR:f LEFTPRNTH inits:i SEMICOLON condition:c SEMICOLON arthmExp:aE RIGHTPRNTH LEFTCBRAC expressions:e RIGHTCBRAC{:
					ForStatement r = new ForStatement(f,i,c,aE,e);
					RESULT = r;
				:}
				;

inits ::= INT:i ID:id EQUAL value:v {:
			Inits r = new Inits(i,id,v); //ACORDARSE QUE EL INT NO ES INT*
			RESULT = r;
		:}
		;

arthmExp ::= ID:id ARTHMEXPSUM:aES1 ARTHMEXPSUM:aES2 {:
				if(aES1 == aES2){
					ArthmExp r = new ArthmExp(id,aES1,aES2);
					RESULT = r;
				}else{
					ERR;// REVISAR COMO TIRAR ERRORES SIN QUE QUIEBRE
				}
			:}
			;

