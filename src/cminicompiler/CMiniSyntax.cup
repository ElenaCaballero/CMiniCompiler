package cminicompiler;

import java_cup.runtime.*;
import java.io.Reader;
import classes.*;

parser code {:

	public CMiniProgram root = null;

	public void report_error(String message, Object info) {
		StringBuilder m = new StringBuilder("Sintax Error");
		if (info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
			if (s.left >= 0) {
				m.append(" at line "+(s.left+1));
				if (s.right >= 0)
					m.append(", column "+(s.right+1));
			}
		}
		m.append(" : "+message);
		System.err.println(m);
	}

	public void report_fatal_error(String message, Object info) {
		report_error(message, info);
		System.exit(1);
	}

	public void syntax_error(Symbol cur_token) {
		report_error("on Token "+ cur_token.value, cur_token);
	}

:};

terminal INT, CHAR, BOOLEAN, CONSTCHAR, 
    VOID, PRINTF, SCANF, ARTHMEXPSUM, ARTHMEXPMULT, 
    BOOLEXP, SEMICOLON, COLON, COMMA, DOT, LEFTPRNTH, 
    RIGTHPRNTH, LEFTCBRAC, RIGHTCBRAC, LEFTBRAK, 
    RIGHTBRAK, NUMERAL, OR, AND, FOR, WHILE, DO, IF, ELSE, 
    DEFINE, INCLUDE, RETURN, BREAK, NULL, BOOLTOF, ID,
    DECIMALINT, SINGLECHAR, CHAR_CONST, INT_CONST, MAIN;
terminal String STRING_LITERAL;

non terminal CMiniProgram cMiniProgram;
non terminal MainClause mainClause;
non terminal FunctionDeclaration functionDeclaration;
non terminal FunctionList functionList;
non terminal Function function;
non terminal Argument argument;
non terminal ArgumentList argumentList;
non terminal Expression expression;
non terminal Expressions expressions;
non terminal Type type;
non terminal ReturnStatement returnStatement;

//Declaraci√≥n de Variables
non terminal VarDeclare varDeclare;
non terminal List list;


start with cMiniProgram;

cMiniProgram ::= functionDeclaration:fd mainClause:mc functionList:fl {:
					CMiniProgram r = new CMiniProgram(fd, mc, fl);
					RESULT = r;
					parser.root = RESULT;
				:}
				;

mainClause ::= type:i MAIN:m LEFTPRNTH argumentList:a RIGTHPRNTH LEFTCBRAC expressions:e RIGHTCBRAC {:
					MainClause r = new MainClause(i, (String)m, a, e);
					RESULT = r;
				:}
				;

functionDeclaration ::= type:t ID:id LEFTPRNTH argumentList:a RIGTHPRNTH {:
					FunctionDeclaration r = new FunctionDeclaration(t, (String)id, a);
					RESULT = r;
				:}
				|{:
					RESULT = null;
				:}
				;

functionList ::= function:f functionList:fl {:
					FunctionList r = new FunctionList(fl, f);
					RESULT = r;
				:}
				| function:f {:
					FunctionList r = new FunctionList(f);
					RESULT = r; 
				:}
				|{:
					RESULT = null;
				:}
				;

function ::= type:t ID:id LEFTPRNTH argumentList:a RIGTHPRNTH LEFTCBRAC expressions:e RIGHTCBRAC {:
					Function r = new Function(t, (String)id, a, e);
					RESULT = r;
				:}
				;

argumentList ::= argument:a COMMA argumentList:al {:
					ArgumentList r = new ArgumentList(a, al);
					RESULT = r;
				:}
				| argument:a {:
					ArgumentList r = new ArgumentList(a);
					RESULT = r;
				:}
				|{:
					RESULT = null;
				:}
				;

argument ::= type:t ID:id  {:
					Argument r = new Argument(t, (String)id);
					RESULT = r;
				:}
				;

expressions ::= expressions:es SEMICOLON expression:e SEMICOLON returnStatement:rs SEMICOLON {:
					Expressions r = new Expressions(es, e, rs);
					RESULT = r;
				:}
				| expression:e SEMICOLON returnStatement:rs SEMICOLON {:
					Expressions r = new Expressions(e, rs);
					RESULT = r;
				:}
				| returnStatement:rs SEMICOLON {:
					Expressions r = new Expressions(rs);
					RESULT = r;
				:}
				|{:
					RESULT = null;
				:}
				;

expression ::= 

///////////////

varDeclare ::= list:l SEMICOLON {: 
								VarDeclare r = new VarDeclare(l);
								RESULT = r; 
						:}
              ;
type ::= INT:i  {: 
								Type r = new Type(i);
								RESULT = r ; 
				:}
        | CHAR:c  {: 	
		        				Type r = new Type(c);
								RESULT = r ; 
				:}
        | BOOLEAN:b {: 	
		    					Type r = new Type(b); 
								RESULT = r ; 
					:}
        ;
list ::= list:l COMMA ID:i {:
								List r = new List(l.tipo);
							:}
		| type:t ID:i 		{:
								List r = new List(t);
							:}
		;
///////////////



